﻿课程名称: **区块链原理与技术**                  任课教师：**郑子彬**| 年级 | 17级 | 专业| 软件工程||--|--|--|--|| 学号 | 17343156 |姓名|张瑜函||电话|18022463778|Email|1009637800@qq.com||开始日期|2019/11/11|完成日期|2019/12/13|## 一、项目背景某车企（宝马）因为其造车技术特别牛，消费者口碑好，所以其在同行业中占据绝对优势地位。因此，在金融机构（银行）对该车企的信用评级将很高，认为他有很大的风险承担的能力。在某次交易中，该车企从轮胎公司购买了一批轮胎，但由于资金暂时短缺向轮胎公司签订了 1000 万的应收账款单据，承诺 1 年后归还轮胎公司 1000 万。这个过程可以拉上金融机构例如银行来对这笔交易作见证，确认这笔交易的真实性。在接下里的几个月里，轮胎公司因为资金短缺需要融资，这个时候它可以凭借跟某车企签订的应收账款单据向金融结构借款，金融机构认可该车企（核心企业）的还款能力，因此愿意借款给轮胎公司。但是，这样的信任关系并不会往下游传递。在某个交易中，轮胎公司从轮毂公司购买了一批轮毂，但由于租金暂时短缺向轮胎公司签订了500万的应收账款单据，承诺1年后归还轮胎公司500万。当轮毂公司想利用这个应收账款单据向金融机构借款融资的时候，金融机构因为不认可轮胎公司的还款能力，需要对轮胎公司进行详细的信用分析以评估其还款能力同时验证应收账款单据的真实性，才能决定是否借款给轮毂公司。这个过程将增加很多经济成本，而这个问题主要是由于该车企的信用无法在整个供应链中传递以及交易信息不透明化所导致的。## 二、项目背景#### 数据流图![在这里插入图片描述](https://img-blog.csdnimg.cn/20191213210412371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ZpY2t5aWlpaWlp,size_16,color_FFFFFF,t_70)#### 存储设计* 债权设计为一个结构体，记录金额、债权人、债务人、生效时间、持有天数、是否还款等债权债务相关信息```contract transaction{  //债权    struct Credit{        uint Arrearsamount;//金额        address creditor;//债权人        address debtor; //债务人        uint startTime;//生效时间        uint keepDays;//持有天数        bool isReturn;//是否还款    }```* 企业信息声明在Company结构体，存储与公司有关的信息，其中credits是一个动态数组，用来存储债权```    //公司    struct Company{        string name;//公司名        Credit[] credits;//债权,可能多个        uint creditRating;//信用等级        uint balances;//企业余额    }```初始化企业```     //初始化企业    function newCompany(string name) public returns(address){        companys[msg.sender].name=name;        companys[msg.sender].creditRating=0;        companys[msg.sender].balances=0;        return msg.sender;    }```获取当前公司拥有的债权``` function getArrears() returns(uint){     address company=msg.sender;     uint result=0;     uint len=companys[company].credits.length;     for(uint i=0;i<len;i++){         if(!companys[company].credits[i].isReturn){             result+=companys[company].credits[i].Arrearsamount;         }     }     return result; }```* 声明状态变量，为每一个可能的地址存储一个`Company```` mapping(address=>Company) public companys;```融资申请声明为一个financingRequest的结构体，包含企业、融资金额、是否同意提供等内容，这些申请存储在一个名为requests的动态数组里``` struct financingRequest{        address company;        uint requestMoney;        bool offered;//是否提供    } financingRequest[]public requests;```* 银行作为第三方可信机构```address public bank;```由银行来向企业进行信用评级和设置金额在设置之前，要确保银行为信息的发出者``` function setBank() {        bank=msg.sender;    }```对企业进行信用评级```function setCreditRating(address Comp,uint rate) public returns(uint) {        require(msg.sender==bank);        companys[Comp].creditRating=rate;        return companys[Comp].creditRating;    }```企业设置金额``` function setBalance(address Comp, uint balanceAmmount) public returns(uint){        require(msg.sender==bank);        companys[Comp].balances=balanceAmmount;        return companys[Comp].balances;    }```### 核心功能介绍* **功能一&功能二——采购商品以及应收账款的转让上链**如果有该债权，则优先进行债权转让如果没有则判断自己的信用等级是否能够签订单据等级达标则签订单据；等级不达标，失败```function Buy (address fromComp,uint nums,uint returnDay)public returns(uint){       //从那里购买物资的公司不能和发出操作的公司是同一个        require(fromComp!=msg.sender);        Credit memory cre;                //公司拥有的债权的数量        uint len=companys[msg.sender].credits.length;                //可转让债权总额        uint transAmount=0;                //计算可转让债权总额        for(uint i=0;i<len;i++){            transAmount+= companys[msg.sender].credits[i].Arrearsamount;        }                //若额度够，则进行转让        if(transAmount>=num){          uint num=nums;          for(uint j=0;j<len;j++){             //若当前债权额度大于要求，则部分转让             //将转让部分加入fromComp的credits队列            if(companys[msg.sender].credits[j].Arrearsamount>=num){                companys[fromComp].credits.push(Credit({                    Arrearsamount:num,                    creditor:fromComp,                    debtor:companys[msg.sender].credits[j].debtor,                    startTime:companys[msg.sender].credits[j].startTime,                    keepDays:companys[msg.sender].credits[j].keepDays,                    isReturn:false                }));            //将转让部分从msg.sender的credits队列中减去                companys[msg.sender].credits[j].Arrearsamount-=num;                break;            }else{                //若当前债权额度小于要求，则全部转让                companys[fromComp].credits.push(Credit({                    Arrearsamount:companys[msg.sender].credits[j].Arrearsamount,                    creditor:fromComp,                    debtor:companys[msg.sender].credits[j].debtor,                    startTime:companys[msg.sender].credits[j].startTime,                    keepDays:companys[msg.sender].credits[j].keepDays,                    isReturn:false                }));                companys[msg.sender].credits[j].Arrearsamount=0;                num-=companys[msg.sender].credits[j].Arrearsamount;            }          }        }else{            //如果自己的信用等级能够签订单据,则自己签订单据向fromComp欠款            if(companys[msg.sender].creditRating>5){                companys[fromComp].credits.push(Credit({                    Arrearsamount:nums,                    creditor:fromComp,                    debtor:msg.sender,                    startTime:now,                    keepDays:returnDay,                    isReturn:false                }));            }else{                //如果不能签订单据，return                return 0;            }        }                     return companys[fromComp].credits.length;    }```* **功能三——利用收账款向银行融资上链**如果信用等级到达标准，可以直接融资；如果等级没达到标  - 如果债权金额总和加上公司已有金额总和大于所需融资总金额,则提供融资- 否则不同意融资 首先编写一个融资需求操作 ``` function newFinancingReq(uint money) {        //不能是银行操作        require(msg.sender!=bank);        //创建一个新的financingRequest对象并把它添加到融资申请队列末尾        requests.push(            financingRequest({              company:msg.sender,              requestMoney:money,              offered:false        })      );    } ``` 银行根据应收账款根据以上原则判断是否给予融资 ``` function offerMoney(address Comp) public returns(bool){        require(msg.sender==bank);        require(Comp!=bank);                //所需融资总数        uint requestAmount=0;                //查看所有该申请者的申请求出所需融资总金额        for(uint i=0;i<requests.length;i++){            if(!requests[i].offered && requests[i].company==Comp){                requestAmount+=requests[i].requestMoney;            }        }                //如果信用等级到达标准，可以直接融资        if(companys[Comp].creditRating>5){            companys[Comp].balances+=requestAmount;            return true;        }                //如果等级没达到标准        //如果债权金额总和加上公司已有金额总和大于所需融资总金额，则提供融资        //否则不同意融资        uint len=companys[Comp].credits.length;        uint creditAmmount=0;                for(uint j=0;j<len;j++){            creditAmmount+=companys[Comp].credits[j].Arrearsamount;        }                //计算可转让债权总额与公司已有金额的总和        uint existAmmount=0;        existAmmount=creditAmmount+companys[Comp].balances;                //大于等于,提供        if(creditAmmount>=requestAmount){            companys[Comp].balances+=requestAmount;            for(uint a=0;a<requests.length;a++){                if(!requests[a].offered && requests[a].company==Comp){                    requests[a].offered=true;                }            }            return true;        }else{            return false;        }    }     ```  * **功能四——应收账款支付结算上链** 债务人可以随时还钱 如债务人未在还钱日期之前还钱，则债权人可讨债还钱```function returnMoney(address Comp,uint value){        uint len=companys[Comp].credits.length;            for(uint i=0;i<len;i++){            if(!companys[Comp].credits[i].isReturn && companys[Comp].credits[i].debtor==msg.sender){                //value小于债务，则value全部偿还                if(value < companys[Comp].credits[i].Arrearsamount){                    companys[Comp].balances+=value;                    companys[msg.sender].balances-=value;                    companys[Comp].credits[i].Arrearsamount-=value;                    break;                }else{                    //value大于等于债务,只需要还欠的金额                    value-=companys[Comp].credits[i].Arrearsamount;                    companys[Comp].balances+=value;                    companys[msg.sender].balances-=value;                    companys[Comp].credits[i].isReturn=true;                }            }        }    }```讨债```function getMoney(address Comp) returns(uint){        uint len=companys[msg.sender].credits.length;        //Comp应偿还金额        uint account=0;                for(uint i=0;i<len;i++){            account+=companys[msg.sender].credits[i].Arrearsamount;            if(!companys[msg.sender].credits[i].isReturn &&             now>(companys[msg.sender].credits[i].startTime+            companys[msg.sender].credits[i].keepDays* 1 days) &&            companys[msg.sender].credits[i].debtor==Comp){                //如果Comp的balances大于等于应偿还金额，讨债成功                if(companys[Comp].balances>=account){                    companys[Comp].balances-=account;                    companys[msg.sender].balances+=account;                    companys[msg.sender].credits[i].isReturn=true;                }else{                    //否则，讨债失败                    break;                }            }        }        return account;    }```### SDK调用先使用fisco-bcos官网教程，将Transaction.sol转化为相应的Transaction.java文件，为SDK调用提供接口。java文件为自动生成，具体内容不做赘述，只需要知道如何调用其生成的接口就行了.```java public RemoteCall<TransactionReceipt> Buy(String fromComp, BigInteger nums, BigInteger returnDay) {}  ...  public RemoteCall<TransactionReceipt> returnMoney(String Comp, BigInteger value){}  ...  public RemoteCall<TransactionReceipt> offerMoney(String Comp){}  ...  public RemoteCall<TransactionReceipt> newFinancingReq(BigInteger money){}  ...   public RemoteCall<TransactionReceipt> getArrears(){}  ...  public RemoteCall<TransactionReceipt> getMoney(String Comp){}  ...  public RemoteCall<String> bank(){}  ...  public RemoteCall<TransactionReceipt> setCreditRating(String Comp, BigInteger rate){}  ...  public RemoteCall<TransactionReceipt> setBank(){}  ...  public RemoteCall<Tuple3<String, BigInteger, BigInteger>> companys(String param0){}  ...  public RemoteCall<TransactionReceipt> setBalance(String Comp, BigInteger balanceAmmount){}  ...  public RemoteCall<TransactionReceipt> newCompany(String name){}  ... ```SDK调用程序名为**BussiApp.java**，代码封装在一个名为`BussiApp`的类里**loadConfig**```javapublic boolean loadConfig() throws Exception{		context = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");		Service service = context.getBean(Service.class);        service.run();        ChannelEthereumService channelEthereumService = new ChannelEthereumService();        channelEthereumService.setChannelService(service);        web3j = Web3j.build(channelEthereumService,service.getGroupId());        boolean flag=false;        if(web3j!=null){        	flag=true;        }        PublicAddressConf conf = context.getBean(PublicAddressConf.class);        addressConf = conf.getAllPublicAddress();        return flag;	}```**deploy**部署合约```javapublic Address deployContract(String keyStoreFileName,String keyStorePassword, String keyPassword) throws Exception{		if (web3j == null )			return null;		Credentials credentials=loadkey(keyStoreFileName,keyStorePassword,keyPassword);		if(credentials==null){			return null;		}	    //Service service = context.getBean(Service.class);	    //service.run();		try {			tran=Transaction.deploy(web3j, credentials, new StaticGasProvider(gasPrice, gasLimited)).send();			//set bank			tran.setBank().send(); 			System.out.println("set bank successfully!");			System.out.println("deploy sucess!");		}catch(Exception e) {			e.printStackTrace();		}		return new Address(tran.getContractAddress());	}```**初始化公司initCompany**`initCompany`函数需要传入参数为私钥存储文件名称(.jks)，keyStorePassword，keyPassword，公司名称，账户余额以及信用等级首先创建一个Transaction调用`newCompany`函数接口，初始化成功在屏幕上输出相应信息随后再创建一个Transaction调用`load`函数接口，加载deploy中的第三方地址，在调用transaction.java中的`setBalance`和`setCreditRating`接口为公司赋予账户余额和信用等级，同时在屏幕上输出是否成功的信息。```javapublic Boolean initCompany(String keyStoreFileName,String keyStorePassword,String keyPassword,String address,String CompN,String num,String creRate)throws Exception{		Boolean flag = false;		BigInteger balan=new BigInteger(num);		BigInteger creR=new BigInteger(creRate);		if (web3j == null ) {			System.out.println("did not set web3j");		}				Credentials credentials=loadkey(keyStoreFileName,keyStorePassword,keyPassword);		if(credentials==null){			System.out.println("did not set credentials");		}				try {			Transaction tran1=Transaction.load(address.toString(), web3j,  credentials, new StaticGasProvider(gasPrice, gasLimited));			//set Bank			tran1.newCompany(CompN).send();			System.out.printf("init company '%s' successfully!\n" , CompN);			Credentials bankCred=loadkey("user.jks","123456","123456");			Transaction theBank=Transaction.load(address.toString(), web3j, bankCred,new StaticGasProvider(gasPrice, gasLimited));			if(theBank!=null) {				//get public key				String addr=getPublicKey(keyStoreFileName,keyStorePassword,keyPassword);				System.out.println(addr);				System.out.println(addressConf.get("User"));				if(addressConf.get("bjyx")==null) {					System.out.println("nothing");				}				else {					System.out.println(addressConf.get("bjyx"));				}								//theBank set Balance for the company				theBank.setBalance(addr,balan).send();				System.out.printf("init '%s' balance successfully!\n", CompN);								//theBank set creditRating for the comapy				theBank.setCreditRating(addr,creR).send();				System.out.printf("init '%s' creditRating successfully!\n" , CompN);								flag=true;			}else {				System.out.printf("init '%s' balance and creditRating failed\n", CompN);			}		}catch(Exception e) {			e.printStackTrace();		}		return flag;	}```**购买物品buySthFromAnoComp**同样需要传入私钥存储文件名称(.jks)，keyStorePassword，keyPassword以确定操作主体，以后的每个操作都需要传入它们和智能合约部署地址，故在下文中不做赘述。还需传入公司名称，购买金额以及拖欠时长, 定义一个result用来记录目标公司持有的白条数目，首先通过`addressConf.get`接口获取目标公司地址，在调用`Buy`函数进行交易。```java//buy things from another company through oweing money	public Boolean buySthFromAnoComp(String keyStoreFileName,String keyStorePassword, String keyPassword,String address,String fromComp,String num,String days) {		String result=new String("-1");		BigInteger money=new BigInteger(num);		BigInteger delays=new BigInteger(days);				if (web3j == null ) {			System.out.println("did not set web3j");			return false;		}		Credentials credentials=loadkey(keyStoreFileName,keyStorePassword,keyPassword);		if(credentials==null){			System.out.println("did not set credentials");			return false;		}				try {			Transaction tran1=Transaction.load(address.toString(), web3j, credentials, new StaticGasProvider(gasPrice, gasLimited));			String fromAddr=addressConf.get(fromComp);			TransactionReceipt receipt=tran1.Buy(fromComp, money, delays).send();			result=tran1.getBuyOutput(receipt).getValue1().toString();			System.out.printf("%s have %s arrears now\n", fromComp,result);			}catch(Exception e) {			e.printStackTrace();		}		return true;	}```**请求融资askForHelp**传入参数融资金额定义一个Boolean变量名为result，来记录是否融资成功。首先调用`newFinancingReq`接口初始化一个融资请求。然后创建一个名为theBank的Transaction变量通过`loadKey`、`load`等函数将theBank设置为操作进行者，调用`offerMoney`接口进行功能调用。在屏幕上输出结果信息。```javapublic Boolean askForHelp(String keyStoreFileName,String keyStorePassword, String keyPassword,String address,String num) {		Boolean result=false;		BigInteger asknum=new BigInteger(num);		if (web3j == null ) {			System.out.println("did not set web3j");			return false;		}		Credentials credentials=loadkey(keyStoreFileName,keyStorePassword,keyPassword);		if(credentials==null){			System.out.println("did not set credentials");			return false;		}				try {			Transaction tran1=Transaction.load(address.toString(), web3j, credentials, new StaticGasProvider(gasPrice, gasLimited));			tran1.newFinancingReq(asknum).send();			String publicAddr=getPublicKey(keyStoreFileName,keyStorePassword,keyPassword);			Credentials bankCred=loadkey("user.jks","20260805","20260805");			Transaction theBank=Transaction.load(address.toString(), web3j, credentials, new StaticGasProvider(gasPrice, gasLimited));			if(theBank!=null) {				TransactionReceipt receipt=theBank.offerMoney(publicAddr).send();				result=theBank.getOfferMoneyOutput(receipt).getValue1();			}else {				System.out.println("There is no bank!");			}			System.out.println("The bank accepts your financing request and provide you "+asknum);		}catch(Exception ex) {			ex.printStackTrace();		}		return result;	}```**还钱returnToMoney**传入归还公司的名称toComp和归还金额同样创建一个Transaction变量，获取toComp的地址在屏幕上输出信息调用`returnMoney`函数接口，在屏幕上输出信息```javapublic Boolean returnToMoney(String keyStoreFileName,String keyStorePassword, String keyPassword,String address,String toComp,String money) {		Boolean flag=false;				if (web3j == null ) {			System.out.println("did not set web3j");			return false;		}		Credentials credentials=loadkey(keyStoreFileName,keyStorePassword,keyPassword);		if(credentials==null){			System.out.println("did not set credentials");			return false;		}				try {			Transaction tran1=Transaction.load(address.toString(), web3j, credentials, new StaticGasProvider(gasPrice, gasLimited));			String toAddr=addressConf.get(toComp);			if(toAddr==null) {				System.out.printf("No such company: %s", toComp);				return false;			}			tran1.returnMoney(addressConf.get(toComp),new BigInteger(money)).send();						System.out.printf("Return %s to %s successfully!\n",toComp,money);			flag=true;		}catch(Exception ex) {			ex.printStackTrace();		}		return flag;	}```**强制还钱rabMoney**传入参数讨债公司名称，在函数中通过`addressConf.get`得到相应的地址，查看此地址是否存在，在屏幕上输出相应信息。创建Transaction对象，调用`getMoney`接口，同时定义一个String类型的theReturn通过`getGetMoneyOutput`来接收调用输出信息```javapublic Boolean rabMoney(String keyStoreFileName,String keyStorePassword, String keyPassword,String address,String fromComp) {		Boolean flag=false;				if (web3j == null ) {			System.out.println("did not set web3j");			return false;		}		Credentials credentials=loadkey(keyStoreFileName,keyStorePassword,keyPassword);		if(credentials==null){			System.out.println("did not set credentials");			return false;		}				try {			Transaction tran1=Transaction.load(address.toString(), web3j, credentials, new StaticGasProvider(gasPrice, gasLimited));			String fromAddr=addressConf.get(fromComp);			if(fromAddr==null) {				System.out.printf("No such company: %s", fromComp);				return false;			}						TransactionReceipt receipt=tran1.getMoney(fromAddr).send();			String theReturn=tran1.getGetMoneyOutput(receipt).getValue1().toString();			System.out.printf("You have got % forcely from %s\n" , theReturn,fromComp);			flag=true;		}catch(Exception ex) {			ex.printStackTrace();		}				return flag;	}```**命令行界面**的实现在**Main.java**里所有功能用Main类封装在界面初始，首先要输出功能指令的调用方法以及所需参数```javaprivate static String LOGO = "\n"             + "命令输入参考如下！ \n"            + "工厂合约部署：./evidence deploy keyStoreFileName keyStorePassword keyPassword  \n"            + "init Company：./evidence init keyStoreFileName keyStorePassword keyPassword aAddress CompN num  creRate \n"            + "buy things：./evidence buy keyStoreFileName keyStorePassword keyPassword address fromComp num days \n"            + "ask for financing request：./evidence request keyStoreFileName keyStorePassword keyPassword address num \n"            + "return money：./evidence return keyStoreFileName keyStorePassword keyPassword address toComp money \n"			+ "forcely get money: ./evidence forcelyget keyStoreFileName keyStorePassword keyPassword address fromComp"            + "getPublicKey：./evidence getPublicKey keyStoreFileName keyStorePassword keyPassword  \n";...System.out.println(LOGO);```构建main函数，输入参数最小为4，运用switch通过识别输入的第一个参数进行功能分类，进行不同的调用，一共分为了`deploy`、`init`、`buy`、`request`、`return`、`forcelyget`、`getPublicKey` 7类，每一类会在屏幕上输出不同的信息```java		switch (args[0]) {			//deploy		 	case "deploy":		 		//此方法需要传入3个参数，参数1为keyStoreFileName（私钥文件名），参数2为keyStorePassword，参数3为keyPassword		 		address=app.deployContract(args[1],args[2],args[3]);		 		System.out.println("=========== deploy factoryContract success, address: " + address.toString()+"=========");		 		break;		 	//init company		 	case "init":		 		//传入7个参数，前三个分别1为keyStoreFileName（私钥文件名），参数2为keyStorePassword，参数3为keyPassword		 		//传入参数需要步数的工厂合约地址，company的name,company的balance,company的creditRating		 		//System.out.println("initCompany(String keyStoreFileName,String keyStorePassword,String keyPassword,String address,String CompN,String num,String creRate)");		 		Boolean flag=app.initCompany(args[1], args[2], args[3], args[4], args[5], args[6], args[7]);		 		System.out.println("*******init company success! "+ flag+"*********");		 		break;		 				 	//buy things from another comp		 	case "buy":		 		//7个参数，1-keyStoreFileName（私钥文件名）,2-keyStorePassword,3-keyPassword		 		//load合约的address,fromComp借钱公司，金额num，天数days		 		//System.out.println("buySthFromAnoComp(String keyStoreFileName,String keyStorePassword, String keyPassword,String address,String fromComp,String num,String days)");		 		Boolean flag1=app.buySthFromAnoComp(args[1],args[2], args[3], args[4], args[5], args[6], args[7]);		 		if(flag1==true) {		 			System.out.println("**********buy success!"+flag1+"************");		 		}else {		 			System.out.println("**********buy failed!"+flag1+"************");		 		}		 		break;		 				 	//ask for financing request		 	case "request":			 		//System.out.println("askForHelp(String keyStoreFileName,String keyStorePassword, String keyPassword,String address,String num)");		 		Boolean flag2=app.askForHelp(args[1], args[2], args[3], args[4], args[5]);		 		if(flag2) {		 			System.out.println("*********finish handle your request!********");		 		}else {		 			System.out.println("*********your request is not allowed!*********");		 		}		 		break;		 				 	//return money to another comp		 	case "return":		 		//System.out.println("returnToMoney(String keyStoreFileName,String keyStorePassword, String keyPassword,String address,String toComp,String money)");		 		Boolean flag3=app.returnToMoney(args[1], args[2], args[3], args[4], args[5], args[6]);		 		if(flag3) {		 			System.out.println("**********return finished! success!*******");		 		}else {		 			System.out.println("**********return failed!******************");		 		}		 		break;		 				 	//forcely get money from another comp		 	case "forcelyget":		 		//System.out.println("rabMoney(String keyStoreFileName,String keyStorePassword, String keyPassword,String address,String fromComp)");		 		Boolean flag4=app.rabMoney(args[1], args[2], args[3], args[4], args[5]);		 		if(flag4) {		 			System.out.println("**********forcelyget money succeed!*********");		 		}else {		 			System.out.println("**********forcelyget money failed.**********");		 		}		 	break;		 				 			 	case "getPublicKey":		 		String publicKey=app.getPublicKey(args[1], args[2], args[3]);		 		System.out.println("---------publicKey:"+publicKey);		 		break;		 	default:                 break;		}		System.exit(0);	}	}```## 三、功能测试本次项目是根据fisco-bcos官网上的evidenceSample改写的，没有进行图形界面的开发，在命令行上运行。* **部署合约**`./evidence deploy user.jks '123456' '123456'`![在这里插入图片描述](https://img-blog.csdnimg.cn/20191213230203185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ZpY2t5aWlpaWlp,size_16,color_FFFFFF,t_70)显示>set bank successfully!>deploy successfully!返回部署合约地址* **创建公司**在创建公司之前，首先要配置其需要的公钥和私钥信息输入如下指令，创建角色对应的私钥文件，这里以bx.jks为例> keytool -genkeypair -alias ec -keyalg EC -keysize 256 -sigalg SHA256withECDSA  -validity 365 -storetype JKS -keystore bx.jks -storepass 20261005将创建好的.jks文件放入/evidence/src/main/resources和/evidence_toolkit/conf文件夹下再使用指令`./evidence getPublicKey bx.jks '20261005' '20261005'`获得其对应的公钥，用来配置applicationContext.xml文件![在这里插入图片描述](https://img-blog.csdnimg.cn/20191213225900260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ZpY2t5aWlpaWlp,size_16,color_FFFFFF,t_70)做好准备就可以创建公司了新建公司名为bx，账户10000，信用等级为10 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191213230547115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ZpY2t5aWlpaWlp,size_16,color_FFFFFF,t_70) 新建公司名为Wyb，账户10000，信用等级为1 ![在这里插入图片描述](https://img-blog.csdnimg.cn/2019121323091611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ZpY2t5aWlpaWlp,size_16,color_FFFFFF,t_70) 新建公司名为xfx，账户10000，信用等级为2 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191213231116602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ZpY2t5aWlpaWlp,size_16,color_FFFFFF,t_70) bx向Wyb **购买东西**，价值2000，于是Wyb有2000高信用的债权 bx向xfx **购买东西**，价值500，于是xfx有500高信用债权 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191213231634531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ZpY2t5aWlpaWlp,size_16,color_FFFFFF,t_70) bx向银行 **请求融资** 20000，因为bx的信用等级很高，银行直接向其提供融资 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191213232113676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ZpY2t5aWlpaWlp,size_16,color_FFFFFF,t_70) Wyb向银行请求融资11000，因为本身有10000，又拥有bx欠下的2000债权，所以融资成功![在这里插入图片描述](https://img-blog.csdnimg.cn/20191213232036321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ZpY2t5aWlpaWlp,size_16,color_FFFFFF,t_70) 同样，xfx因为信用等级低且账户金额和债权总额相加小于11000，融资失败 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191213232404715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ZpY2t5aWlpaWlp,size_16,color_FFFFFF,t_70)  bx又向xfx买了价值500的东西，0天后归还，xfx可以**要账**![在这里插入图片描述](https://img-blog.csdnimg.cn/20191213233041281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ZpY2t5aWlpaWlp,size_16,color_FFFFFF,t_70)bx 向Wyb **主动归还** 欠款![在这里插入图片描述](https://img-blog.csdnimg.cn/2019121323322591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ZpY2t5aWlpaWlp,size_16,color_FFFFFF,t_70)## 四、界面展示![在这里插入图片描述](https://img-blog.csdnimg.cn/20191213233301819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ZpY2t5aWlpaWlp,size_16,color_FFFFFF,t_70)为命令行界面，每次执行完指令后，会出现**命令参考** ，显示可执行的指令以及指令需要的参数，便于操作指令执行完毕后，会有相应的返回值或者成功还是失败的消息提示## 五、心得体会       这次作业难度对我来说其实是有点大的，用了很多时间和精力，踩了特别特别多的坑。在项目进行的过程中，我认为智能合约的编写相对来说算是比较容易的，因为逻辑很简单，要实现的功能也很清晰，只要理清了思路就是语法的问题。还好fisco-bcos有官方文档提供了现成的智能合约的编写例子，solidity学起来并不难。   最让我头秃的是项目的第三阶段，我已经两天没睡觉了，感觉在猝死的边缘疯狂试探，一开始环境就配了很久，在nodejs和JavaSDK之间反复切换反复纠结（因为我不是很会啊呜呜呜呜），光是查阅相关资料学习语法和用法就用了一周的时间，再加上一开始对于区块链前端后端链端的概念比较模糊，不知道怎样联系起来，也废了很多功夫。   想起来全是泪啊，但是做出来有很大的成就感，重要的是通过这次大项目我掌握了很多知识，能力有了提升。   最后，老师和TA辛苦啦。  